#!/usr/bin/env python3
#show the HBA cards used, the chassis size, if the chassis is a hybrid or not,
#if CAS is used or not, the devices used, and which devices are cores


###################################################################################################################################################################################

import subprocess
import re
import os
import sys
from optparse import OptionParser

###################################################################################################################################################################################
#   get_path_variables()
# ARGS: none
# DESC: get the path variables needed for all other functions
###################################################################################################################################################################################
def get_path_variables():
    # get the alias config path, if it fails, assume /etc
    # get the device path, if it fails, assume /dev
    
    conf_path = os.getenv('ALIAS_CONFIG_PATH')
    if conf_path == None:
        log("No alias config path set in profile.d ... Defaulting to /etc")
        conf_path = "/etc"
    dev_path = os.getenv('ALIAS_DEVICE_PATH')
    if dev_path == None:   
        log("No device path set in profile.d ... Defaulting to /etc")
        dev_path = "/dev"
    
    return conf_path, dev_path
    
    
##################################################################################################################################################################################
#   getHba(hbas)
# ARGS: hbas ( a list of numbers which identify "plugged in" hba cards listed by the lspci command )
# DESC: get the number of HBA cards that are "plugged in". The card numbers are "hardwritten" in the main function and passed to getHba(hbas) as a list.
##################################################################################################################################################################################
def getHba(hbas):
    hbaCards = []
    allPcis = subprocess.Popen(["lspci"], universal_newlines = True, stdout = subprocess.PIPE).stdout
    for line in allPcis:                                    
        for card in hbas:
            regex = re.search("({c})".format(c = card), line)
            if regex != None:
                hbaCards.append(regex.group(0))
                
    return hbaCards
    
    
##################################################################################################################################################################################
#   getChassis(hbaCards)
# ARGS: hbaCards ( a list of hba cards found )
# DESC: get the size of the chassis, based on the quantity of HBA cards. This will work if the chassis is not a 
#   hybrid chassis, because it effectively multiplies the number of HBA cards by 15. Returns the chassis size.
#   takes the list of hba cards as an argument
##################################################################################################################################################################################
def getChassis(hbaCards):
    hbaQuantity = len(hbaCards)
    if hbaQuantity == 0:
        return "No Supported HBA Detected"
    else:
        switch = { 
        1: "15",
        2: "30",
        3: "45",
        4: "60"
        }
        if (hbaQuantity == 1 or hbaQuantity == 2 or hbaQuantity == 3 or hbaQuantity == 4):
            chassisSize = switch.get(hbaQuantity)
        else:
            chassisSize = "No Supported HBA Detected"
    return chassisSize
    
    
##################################################################################################################################################################################
#   hybridChassisCheck()
# ARGS: none
# DESC: Check if the machine has a hybrid chassis (has some 24i slots) or not. Returns a boolean which is True if there is a 24i slot and false otherwise
##################################################################################################################################################################################  
def hybridChassisCheck():
    a = None
    hybridChassis = 0
    
    a = subprocess.Popen(["/opt/tools/storcli64", "show", "all"], stdout = subprocess.PIPE, universal_newlines = True).stdout
    for line in a:
        b = re.search( "24i", line) 
        if b != None:
            hybridChassis += 1
    if hybridChassis > 0:
        return True
    else:
        return False
        
        
##################################################################################################################################################################################
#   checkCas()
# ARGS: none
# DESC: finds out if the machine is running open-cas-linux and returns a boolean which is True if open-cas-linux is being run and false otherwise
##################################################################################################################################################################################              
def checkCas():
    if subprocess.run(["rpm", "-q", "open-cas-linux"], stdout = subprocess.PIPE, universal_newlines = True).returncode == 0:
        if subprocess.run(["casadm", "-L"], stdout = subprocess.PIPE, universal_newlines = True).stdout == "No chaches running":
            CAS = False
        else:
            CAS = True
    else:
        CAS = False
        
    return CAS
    
    

##################################################################################################################################################################################
#   getBAYS(DEVICE_PATH)
# ARGS: none
# DESC: gets the device name and the symbolic link that points to it. Returns a list containing tuples. Each tuple has a symbolic link and the device (file) that it points to.
##################################################################################################################################################################################
def getBAYS(DEVICE_PATH):
    BAYS = []
    allBays=subprocess.Popen(["cat", "/etc/vdev_id.conf"], stdout = subprocess.PIPE, universal_newlines = True).stdout
    for line in allBays:
        regex = re.search("^alias\s(\S+)\s", line)                                                              
        if regex != None:
            bay = regex.group(1)
            if subprocess.run(["ls", DEVICE_PATH+"/"+bay],stderr = subprocess.PIPE, stdout = subprocess.PIPE, universal_newlines = True).returncode == 0:
            # if there is a symbolic link in the specified path, check what device it points to. Append the symbolic link and the device to a list.
                symLinkDestination = subprocess.run(["readlink", DEVICE_PATH+"/"+bay], stdout=subprocess.PIPE, universal_newlines=True).stdout
                symLinkDestination = symLinkDestination.strip()
                BAYS.append((bay, symLinkDestination))
    return BAYS

    
##################################################################################################################################################################################
#   getEverythingToGetRidOf(driveTypes, badDrives, DEVICE_PATH)
# ARGS: driveTypes (a list of the arguments provided for the option -i if specified by the user, an empty list otherwise)
#       badDrives  (a list of the arguments provided for the option -e if specified by the user, otherwise an empty list)
#       DEVICE_PATH ( the device path as returned by the getPathVariables function)
##################################################################################################################################################################################  
def getEverythingToGetRidOf(driveTypes, badDrives, DEVICE_PATH):
    caches = []
    cores = []
    HDDs = []
    SSDs = []
    everythingToGetRidOf = []
    # get lists of the core and cache device names
    casadmList = subprocess.Popen(["casadm", "-L", "-o", "csv"], stdout=subprocess.PIPE, universal_newlines=True).stdout
   
    for line in casadmList:
        cache = re.search("^cache,.*,/dev/([A-Za-z]+).*,.*$", line)
        if cache != None:
            caches.append(cache.group(1))
            
    casadmList = subprocess.Popen(["casadm", "-L", "-o", "csv"], stdout=subprocess.PIPE, universal_newlines=True).stdout
    for line in casadmList:
        core = re.search("^core,.*,/dev/([A-Za-z]+).*,.*$", line)
        if core != None:
            cores.append(core.group(1))
                    
    CASDevices = cores+caches
    
    if driveTypes != None:
        # find the symbolic links (aliases) for the devices that match the media type specified on the command line and store them in mediaType
        
        if "HDD" in driveTypes:  
            pass
        else:
            lsdev = subprocess.Popen(["lsdev", "-tdn"], stdout=subprocess.PIPE, universal_newlines=True).stdout
            for line in lsdev:
                HDDs += re.findall("\d+-\d+\s+.+/dev/(.+),HDD.", line)
    
        if "SSD" in driveTypes:
            pass
        else:
            lsdev = subprocess.Popen(["lsdev", "-tdn"], stdout=subprocess.PIPE, universal_newlines=True).stdout
            for line in lsdev:
                SSDs += re.findall("\d+-\d+\s+.+/dev/(.+),SSD.", line)  
        
        everythingToGetRidOf = HDDs+SSDs
        
        if "CAS" in driveTypes:
        #don't add CAS drives to the remove list, eg if you'd normally concatenate mediaType with caches, don't this time
        # Need to handle the case of not adding SSD or HDD as arguments but adding CAS as an argument, in which case you still want the cores.
        # can handle the above case by saying if only CAS was specified, still add the cores. 
            if len(everythingToGetRidOf) != 0:
                for drive in everythingToGetRidOf:
                    for core in cores:
                        if drive == core:
                            everythingToGetRidOf.remove(drive)
                            everythingToGetRidOf.insert(0, None)
        
                while everythingToGetRidOf[everythingToGetRidOf.count(None)-1] == None:
                    everythingToGetRidOf.pop(everythingToGetRidOf.count(None)-1)
                    if len(everythingToGetRidOf) == 0:
                        break
            else:
                # only get rid of drives used for the caches
                everythingToGetRidOf += caches
        else:
            for drive in everythingToGetRidOf:
                    for device in CASDevices:
                        if drive == device:
                            CASDevices.remove(device)
                            CASDevices.insert(0, None)
            while CASDevices[CASDevices.count(None)-1] == None:
                    CASDevices.pop(CASDevices.count(None)-1)
                    if len(CASDevices) == 0:
                        break
            everythingToGetRidOf += CASDevices
    else:
        everythingToGetRidOf += caches
    if badDrives != None:
        for drive in badDrives:
            device=subprocess.run(["readlink", DEVICE_PATH+'/'+drive], stdout=subprocess.PIPE, universal_newlines=True).stdout
            if device != None:
                device = device.strip()
                everythingToGetRidOf.append(device)
            else: 
                driveName = re.search("cas\d+-\d+", drive)
                if driveName.group(0) == None:
                    exit("invalid drive name entered")   
                #else:
                    #just keep going, we don't know for sure if the device is valid or not yet

    return everythingToGetRidOf
    
    
##################################################################################################################################################################################  
#   removeBadDrives(BAYS, everythingToGetRidOf)
# ARGS: BAYS ( a list of the symbolic links and the devices that they point to, or in the case of a core for machines running open-cas-linux, the device name and the core name) 
#    everythingToGetRidOf ( a list of symbolic links/the BAY alias provided by the person running generate-osd-vars )
# DESC: compare the entries in the BAYS and badDrives lists and remove any badDrives from BAYS
##################################################################################################################################################################################    
def removeBadDrives(BAYS, everythingToGetRidOf):
    for SLandDEV in BAYS:
        if len(everythingToGetRidOf) > 0 : #can probably delete this statement because 1) there will always be "something" in everythingToGetRidOf
        # and 2) if what comes next doesn't happen then the program breaks.
            for deviceName in everythingToGetRidOf:
                if deviceName == SLandDEV[1]:
                    BAYS.remove(SLandDEV)
                    BAYS.insert(0, None)
    
    while BAYS[BAYS.count(None)-1] == None:
        BAYS.pop((BAYS.count(None)-1))
        if len(BAYS) == 0:
            break
    print("BAYS before dealing with changing the names of core drives and removing them:")
    print(BAYS)
    return BAYS
    
    
##################################################################################################################################################################################
#   dealWithCoreDrives(BAYS,badDrives)
# ARGS: BAYS
# DESC: renames any cores as the name listed by casadm 
################################################################################################################################################################################   
def dealWithCoreDrives(BAYS, badDrives):
    for BAY in BAYS:
        casadmList = subprocess.Popen(["casadm", "-L", "-o", "csv"], stdout=subprocess.PIPE, universal_newlines=True).stdout
        for line in casadmList:
            core = re.search("^core,.*,/dev/([A-Za-z]+).*,.*,.*,/dev/(cas.*)$", line)
            if core != None :
                if core.group(1) == BAY[1]:
                    if (badDrives != None) and (core.group(2) in badDrives):
                        print("removing:")
                        print(BAY)
                        BAYS.remove(BAY)
                        BAYS.insert(0, None)
                        print("after removing")
                        print(BAYS)
                    else: #this is problematic, we could end up here unintentionally if the name of the drive was a cas drive and was not specified correctly
                        print("replacing:")
                        print(BAY)
                        BAYS.insert(BAYS.index(BAY), (core.group(2), BAY[1]))
                        BAYS.remove(BAY)
    while BAYS[BAYS.count(None)-1] == None:
        BAYS.pop(BAYS.count(None)-1)
        if len(BAYS) == 0:
            break               
                   
##################################################################################################################################################################################
#   displayVars()
# ARGS: none
# DESC: Displays the variables that have been grouped by all other functions 
##################################################################################################################################################################################
def displayVars(hbaCards, chassisSize, hybridChassis, BAYS, DEVICE_PATH):
    print("---")
    print("chassis_size: {chassis}".format(chassis = chassisSize))
    print("hybrid_chassis: {hchassis}".format(hchassis = hybridChassis))
    print("osd_auto_discovery: false")
    print("lvm_volumes:")
    for SLandDEV in BAYS:
        print(" - data: {DP}/{ALIAS}".format(DP = DEVICE_PATH, ALIAS = SLandDEV[0]))
    print('\n')
    print("devices:")
    for SLandDEV in BAYS:
        if SLandDEV[0][0:3] == "cas":
            print(" - {DP}/{SYMLINK}".format(DP = DEVICE_PATH, SYMLINK = SLandDEV[0]))
        else:
            print(" - {DP}/{SYMLINK}".format(DP = DEVICE_PATH, SYMLINK = SLandDEV[1]))
    print('\n')
    	
def main():
    #parse the command line for options and arguments. the only option is the -e one right now. the argument is a string of drives to exclude in the listing.
    badDrives = None  
    driveTypes = None
    badDrivesArgs = []
    driveTypesArgs = []
    parser = OptionParser()
    parser.add_option("-i", "--include-by-drive-type", action="store", type=str, dest="drive_type", nargs=1, default=None, help="-i: only show the drives of the type lsited as arguments to the '-i' option. valid arguments are HDD, SSD, and CAS.")
    parser.add_option("-e", "--exclude-by-drive-alias",action="store", type=str, dest="drive_alias", nargs=1, default=None, help=" -e: only show the drives that have not been  listed as arguments")    
    (options, args) = parser.parse_args()
    if options.drive_alias != None:
        badDrives = options.drive_alias.split()
        #argumentSanityCheck(badDrives, badDrivesArgs)
    if options.drive_type != None:  
        driveTypes = options.drive_type.split() 
        #argumentSanityCheck(driveTypes, driveTypesArgs)
    
    hbas = [ "3224", "3316", "3616", "3008"] #hard coded numbers used to identify HBA cards
    
    pathVariables = get_path_variables()
    DEVICE_PATH = pathVariables[1]
    CONFIG_PATH = pathVariables[0]
    hbaCards = getHba(hbas)
    chassisSize = getChassis(hbaCards)
    hybridChassis = hybridChassisCheck()
    CAS = checkCas()
    BAYS = getBAYS(DEVICE_PATH)
    everythingToGetRidOf = getEverythingToGetRidOf(driveTypes, badDrives, DEVICE_PATH)
    removeBadDrives(BAYS, everythingToGetRidOf)
    dealWithCoreDrives(BAYS, badDrives)
    displayVars(hbaCards, chassisSize, hybridChassis, BAYS, DEVICE_PATH)
  
if __name__ == "__main__":
    main() 