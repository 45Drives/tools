#!/usr/bin/env python3
################################################################################
# dmap - used to create /etc/vdev_id.conf for 45Drives storage servers
#
# Copyright (C) 2020, Josh Boudreau <jboudreau@45drives.com>
#                     Mark Hooper   <mhooper@45drives.com>
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# TODO: fix the get chassis size from user loop (when ./dmap -s 45, then 13 ..look at the mod) 
#     
################################################################################

################################################################################
# dmap is used to create /etc/vdev_id.conf 

######################### EXAMPLE /etc/vdev_id.conf ############################
#alias 1-1     /dev/disk/by-path/pci-0000:03:00.0-sas-phy2-lun-0
#alias 1-2     /dev/disk/by-path/pci-0000:03:00.0-sas-phy3-lun-0
#alias 1-3     /dev/disk/by-path/pci-0000:03:00.0-sas-phy1-lun-0
#alias 1-4     /dev/disk/by-path/pci-0000:03:00.0-sas-phy0-lun-0
#alias 1-5     /dev/disk/by-path/pci-0000:03:00.0-sas-phy6-lun-0
#alias 1-6     /dev/disk/by-path/pci-0000:03:00.0-sas-phy7-lun-0
#alias 1-7     /dev/disk/by-path/pci-0000:03:00.0-sas-phy5-lun-0
#alias 1-8     /dev/disk/by-path/pci-0000:03:00.0-sas-phy4-lun-0
#alias 1-9     /dev/disk/by-path/pci-0000:03:00.0-sas-phy18-lun-0
#alias 1-10     /dev/disk/by-path/pci-0000:03:00.0-sas-phy19-lun-0
#alias 1-11     /dev/disk/by-path/pci-0000:03:00.0-sas-phy17-lun-0
#alias 1-12     /dev/disk/by-path/pci-0000:03:00.0-sas-phy16-lun-0
#alias 1-13     /dev/disk/by-path/pci-0000:03:00.0-sas-phy22-lun-0
#alias 1-14     /dev/disk/by-path/pci-0000:03:00.0-sas-phy23-lun-0
#alias 1-15     /dev/disk/by-path/pci-0000:03:00.0-sas-phy21-lun-0
#alias 2-1     /dev/disk/by-path/pci-0000:04:00.0-sas-phy2-lun-0
#alias 2-2     /dev/disk/by-path/pci-0000:04:00.0-sas-phy3-lun-0
#alias 2-3     /dev/disk/by-path/pci-0000:04:00.0-sas-phy1-lun-0
#alias 2-4     /dev/disk/by-path/pci-0000:04:00.0-sas-phy0-lun-0
#alias 2-5     /dev/disk/by-path/pci-0000:04:00.0-sas-phy6-lun-0
#alias 2-6     /dev/disk/by-path/pci-0000:04:00.0-sas-phy7-lun-0
#alias 2-7     /dev/disk/by-path/pci-0000:04:00.0-sas-phy5-lun-0
#alias 2-8     /dev/disk/by-path/pci-0000:04:00.0-sas-phy4-lun-0
#alias 2-9     /dev/disk/by-path/pci-0000:04:00.0-sas-phy18-lun-0
#alias 2-10     /dev/disk/by-path/pci-0000:04:00.0-sas-phy19-lun-0
#alias 2-11     /dev/disk/by-path/pci-0000:04:00.0-sas-phy17-lun-0
#alias 2-12     /dev/disk/by-path/pci-0000:04:00.0-sas-phy16-lun-0
#alias 2-13     /dev/disk/by-path/pci-0000:04:00.0-sas-phy22-lun-0
#alias 2-14     /dev/disk/by-path/pci-0000:04:00.0-sas-phy23-lun-0
#alias 2-15     /dev/disk/by-path/pci-0000:04:00.0-sas-phy21-lun-0"

# an example formatted string that can be used to make the required entries:
#"alias {bay}     {dev_path}/disk/by-path/pci-0000:{pci_slot}-sas-phy{lut}-lun-0".format(bay="",dev_path="",pci_slot="",lut="")


import re
import subprocess
import os
import sys
from optparse import OptionParser

g_quiet = False
g_supported_chassis_sizes = [15,30,32,45,60]

# a look up table used to ensure that the physical path is assigned in
# the correct order for each hba card that we use. The keys are 
# set so that they match the output from lspci.
lut = {
	"SAS3224": [2,3,1,0,6,7,5,4,18,19,17,16,22,23,21,20] # PCI Card - 9305-16
	}
	
controller_types = lut.keys()
	
def get_controller_types():
# lspci - get the controller type, and the order in which cards are installed
	controllers = []
	try:
		lspci_result = subprocess.Popen(["lspci"], stdout=subprocess.PIPE,
			universal_newlines=True).stdout
	except OSError:
		log("Error executing lspci.")
		sys.exit(1)
	for line in lspci_result:
		for key in controller_types:
			regex = re.search("^(\S+).*{hba}.*$".format(hba=key),line)
			if regex != None:
				controllers.append((regex.group(1),key))
	return controllers
				
def get_chassis_size():
	# ipmitool fru - to get the chassis size (get user to put it in if unsuccessful)
	chassis_size = 0
	try:
		ipmitool_result = subprocess.Popen(["ipmitool","fru"], stdout=subprocess.PIPE,
			universal_newlines=True).stdout
	except OSError:
		return chassis_size
	for line in ipmitool_result:
			regex = re.search("^\s+Product Part Number\s+:\s+\w{0,2}(\d{2})\w?$",line)
			if regex != None:
				chassis_size = int(regex.group(1))
				return chassis_size
	return chassis_size


def get_path_variables():
	# get the alias config path, if it fails assume /etc/
	# get the device path, if it fails assume /dev/
	conf_path = os.getenv('ALIAS_CONFIG_PATH')
	if conf_path == None:
		log("No alias config path set in profile.d ... Defaulting to /etc/")
		conf_path = "/etc/"
	if conf_path[-1] != "/":
		conf_path+="/"	
	
	dev_path = os.getenv('ALIAS_DEVICE_PATH')
	if dev_path == None:
		log("No alias device path set in profile.d ... Defaulting to /dev/")
		dev_path = "/dev/"
	if dev_path[-1] != "/":
		dev_path+="/"
	
	return conf_path, dev_path

def create_config(chassis_size,controller_types,dev_path):
	vdev_id_conf = "# This file was created using dmap (/opt/tools/dmap)\n"
	drives_per_row = 15 if chassis_size%16 != 0 else 16
	for i in range(chassis_size):
		row_index = ((i//drives_per_row)+1)
		card_index = row_index-1
		bay_index = ((i%drives_per_row)+1)
		phy_index = bay_index-1
		line = "alias {row}-{bay}     {dp}disk/by-path/pci-0000:{ct}-sas-phy{phy_num}-lun-0".format(
			row=row_index,
			bay=bay_index,
			dp=dev_path,
			ct=controller_types[card_index][0],
			phy_num=lut[controller_types[card_index][1]][phy_index]
			)
		vdev_id_conf += line + "\n"
	return vdev_id_conf

def check_chassis_size(chassis_size,controller_types):
	if int(chassis_size) not in g_supported_chassis_sizes:
		log(str(chassis_size) + " is not a valid chassis size")
		return False
	elif chassis_size == 32: 
		# stornado
		card_count = chassis_size//16
		if card_count != controller_types:
			log(
				str(chassis_size) + 
				" is not congruent with the number of hba cards detected {ct}".format(
					ct=controller_types
					)
				)
			return False
	elif not chassis_size%15:
		# chassis size is divisible by 15
		card_count = chassis_size//15
		if card_count != controller_types:
			log(
				str(chassis_size) +
				" is not congruent with the number of hba cards detected {ct}".format(
					ct=controller_types
					)
				)
			return False
	return True


def get_chassis_size_from_user(controller_types):
	chassis_size = 0
	while not chassis_size:
		result = input("Cannot determine chassis size.\nPlease indicate total number of hard drive bays: ")
		regex = re.match("\d\d",result)
		if regex != None:
			chassis_size = int(regex.group(0))
			if check_chassis_size(chassis_size,len(controller_types)):
				break	
		else:
			log(result, " is not a valid chassis size")
	return chassis_size

def trigger_udev():
	trigger_successful = False
	try:
		trigger_call = subprocess.run(["udevadm","trigger"])
		if trigger_call.returncode == 0:
			trigger_successful = True
	except OSError:
		log("Error triggering udevadm (udevadm trigger)")
		sys.exit(1)

	if trigger_successful:
		try:
			settle_call = subprocess.run(["udevadm","settle"])
			if settle_call.returncode != 0:
				raise OSError()
		except OSError:
			log("Error settling udevadm (udevadm settle)")
			sys.exit(1)			

def reset_map(config_path):
	try:
		os.remove(config_path + "vdev_id.conf")
	except OSError:
		pass
	trigger_udev()
	log("Drive Aliasing reset")
	sys.exit(0)


def log(message):
	if not g_quiet:
		print(message)

def check_root():
	root_test =	subprocess.run(["ls","/root"],stdout=subprocess.DEVNULL,stderr=subprocess.DEVNULL).returncode
	if root_test:
		log("dmap must be run with root privileges")
		sys.exit(root_test)

def main():
	# ensure that script has been run with root privilages
	check_root()

	parser = OptionParser()
	parser.add_option("-m","--no-udev",action="store_false",dest="trigger_udev",default=True,help="Creates map but doesnt trigger udev rules")
	parser.add_option("-s","--chassis-size",dest="specify_chassis_size",help="Specify chassis size")
	parser.add_option("-q","--quiet",action="store_true",dest="quiet",default=False,help="Quiet Mode")
	parser.add_option("-r","--reset-map",action="store_true",dest="reset_map",default=False,help="Resets the drive map")
	(options, args) = parser.parse_args()
	g_quiet = options.quiet

	# get the path variables required to determine config path and device path
	conf_path, dev_path = get_path_variables()
	
	# erase existing config file and reset map if specified by user (-r)
	if options.reset_map:
		reset_map(conf_path)

	# get the ID and controller type as a list of tuples
	controller_types = get_controller_types()
	
	# calculate chassis size, or use provided option argument (-s)
	chassis_size = get_chassis_size() if not options.specify_chassis_size else int(options.specify_chassis_size)
	# get the chassis size from user if unable to calculate automatically
	if not check_chassis_size(chassis_size,len(controller_types)) and not g_quiet:
		chassis_size = get_chassis_size_from_user(controller_types)
	elif not chassis_size:
		sys.exit(1)
	
	# generate config file as a string
	vdev_id_conf = create_config(chassis_size,controller_types,dev_path)
	
	# write file to disk
	f = open(conf_path + "vdev_id.conf","w")
	f.write(vdev_id_conf)
	f.close()

	#trigger udev
	if options.trigger_udev:
		trigger_udev()

	#print config file to stdout
	log(vdev_id_conf)

if __name__ == "__main__":
    main()
