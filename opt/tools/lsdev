#!/usr/bin/env python3
################################################################################
# lsdev - List devices in the system by their alias
#
# Copyright (C) 2020, Josh Boudreau <jboudreau@45drives.com>
#                     Mark Hooper   <mhooper@45drives.com>
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# TODO:
# - Fix print width formatting for model number (serial)
# - re-tune lsosd (low priority)
################################################################################

import json
import re
import os
import subprocess
from optparse import OptionParser
import math
from enum import Enum

EXIT_CODE = 0

# escape sequences for supported color options
class ANSI_colours:
	LGREEN='\033[1;32m'
	GREEN='\033[0;32m'
	RED='\033[0;31m'
	GREY='\033[1;30m'
	END='\033[0m'

# characters used to draw box around lsdev output
class box:
	TL=u'\u2554' # ╔
	TR=u'\u2557' # ╗
	BL=u'\u255a' # ╚
	BR=u'\u255d' # ╝
	H=u'\u2550'  # ═
	V=u'\u2551'  # ║
	TT=u'\u2566' # ╦
	LT=u'\u2560' # ╠
	RT=u'\u2563' # ╣
	BT=u'\u2569' # ╩
	CT=u'\u256C' # ╬

class outputType(Enum):
	DEFAULT = 0
	HEALTH = 1
	MODEL = 2
	TYPE = 3
	SERIAL = 4

class model_serial_ind:
	MODEL = 0
	SERIAL = 1

################################################################################
# function name: count_partitions
# receives: block device path
# does: reads /proc/partitions, counts lines matching device base name followed
#       by an integer
# returns: number of partitions on device referenced by path
################################################################################
def count_partitions(path):
	partitions = open("/proc/partitions", mode='r')
	blk_name = os.path.basename(path)
	return len(re.findall(blk_name + "\d{1,2}",partitions.read(),re.MULTILINE))

################################################################################
# function name: smartctl_needed
# receives: options from CLI flags
# does: check if smartctl() needs to be called
# returns: True if smartctl() needs to be called, else False
################################################################################
def smartctl_needed(options):
	return options.json or options.outputHealth

################################################################################
# function name: smartctl
# receives: drive dictionary from build_server()
# does: executes smartctl -a --json <drive path> and saves output values
#       in drive dictionary
# returns: nothing
################################################################################
def smartctl(drive):
	global EXIT_CODE
	try:
		child = subprocess.Popen(["smartctl", "-a", drive["dev"], "--json"],
				stdout=subprocess.PIPE, universal_newlines=True)
	except OSError:
		print("Error executing smartctl. Is it installed?")
		exit(1)
	if child.wait() != 0:
		EXIT_CODE = child.returncode
		return
	output = json.loads(child.stdout.read())
	drive["model-family"] = output["model_family"] if "model_family" in output.keys() else "?"
	drive["model-name"] = output["model_name"] if "model_name" in output.keys() else "?"
	drive["serial"] = output["serial_number"] if "serial_number" in output.keys() else "?"
	drive["capacity"] = output["user_capacity"]["bytes"] if "user_capacity" in output.keys() else "?"
	drive["firm-ver"] = output["firmware_version"] if "firmware_version" in output.keys() else "?"
	drive["rotation-rate"] = output["rotation_rate"] if "rotation_rate" in output.keys() else "?"
	for attr in output["ata_smart_attributes"]["table"]:
		if attr["name"] == "Start_Stop_Count":
			drive["start-stop-count"] = attr["raw"]["string"]
		elif attr["name"] == "Power_Cycle_Count":
			drive["power-cycle-count"] = attr["raw"]["string"]
		elif attr["name"] == "Temperature_Celsius":
			drive["temp-c"] = attr["raw"]["string"].split()[0] + u"\u2103"
		elif attr["name"] == "Current_Pending_Sector":
			drive["current-pending-sector"] = attr["raw"]["string"]
		elif attr["name"] == "Offline_Uncorrectable":
			drive["offline-uncorrectable"] = attr["raw"]["string"]
	drive["power-on-time"] = output["power_on_time"]["hours"] if "power_on_time" in output.keys() else "?"
	drive["health"] = "OK" if output["smart_status"]["passed"] else "POOR"

################################################################################
# function name: lsblk_needed
# receives: options from CLI flags
# does: check if get_model_serial() needs to be called
# returns: True if get_model_serial() needs to be called, else False
################################################################################
def lsblk_needed(options):
	return (not smartctl_needed(options)) and (options.outputModel or options.outputSerial)

################################################################################
# function name: get_model_serial
# receives: nothing
# does: creates dictionary of hard drive model numbers
#       and serial numbers with the device path as the key
# returns: dictionary of model and serial numbers
################################################################################
def get_model_serial():
	model_serial = {}
	try:
		lsblk_result = subprocess.Popen(
			["lsblk","-a","-n","-r","-o","name,model,serial"],
			stdout=subprocess.PIPE,universal_newlines=True
		).stdout
	except OSError:
		print("Error executing lsblk.")
		exit(1)
	for line in lsblk_result:
		regex = re.search("^(sd[a-z]{1,2})\s+([^\s]+)\s+([^\s]+)$",line)
		if regex == None:
			continue
		drive_path = "/dev/" + regex.group(1) # /dev/sd<x>
		model = regex.group(2).replace("\\x20"," ") # replace ascii space with " "
		serial = regex.group(3).replace("\\x20"," ")
		model_serial[drive_path] = (model, serial)
	return model_serial

################################################################################
# function name: build_server
# receives: CLI options
# does: checks if smartctl or get_model_serial need to be called,
#       opens vdev_id.conf, iterates through lines and creates 2D array in
#       server["rows"] containing bay dictionaries, sets values in bay
#       dictionary before inserting into array. Uses either smartctl() to fill
#       all fields of dictionary, uses dict returned by get_model_serial() to
#       model and serial fields, or uses neither depending on call_smartctl and
#       call_lsblk values.
# returns: server dictionary ({rows: [[]], meta: {}})
################################################################################
def build_server(options):
	call_smartctl = smartctl_needed(options)
	call_lsblk = lsblk_needed(options) # grab model num and serial from lslk (get_model_serial())
	model_serial = get_model_serial() if call_lsblk else {}
	server = [[]]; # server[row][bay]
	CONFIG_PATH = "/etc/zfs" if os.path.isfile("/etc/zfs/vdev_id.conf") else "/etc"
	try:
		vdev_id = open(CONFIG_PATH + "/vdev_id.conf", mode='r')
	except IOError:
		print("Error opening " + CONFIG_PATH + "/vdev_id.conf. Run `dmap`.")
		exit(1)
	row_index = 1
	for line in vdev_id:
		# skip blank lines and comments
		if not line or line == "" or line[0] == '#':
			continue
		# extract bay indices and by-path path
		regex = re.search("^alias (\d{1,2})-(\d{1,2})\s+(.*)$",line)
		if regex == None:
			continue
		new_row_index = int(regex.group(1))
		new_bay_index = int(regex.group(2))
		# new row
		if new_row_index > row_index:
			row_index = new_row_index
			server.append([]); # insert new row
		# process bay
		bay = {
			"dev-by-path": "",
			"bay-id": "",
			"occupied": False,
			"dev": "",
			"partitions": "",
			"model-family": "",
			"model-name": "",
			"serial": "",
			"capacity": "",
			"firm-ver": "",
			"rotation-rate": "",
			"start-stop-count": "",
			"power-cycle-count": "",
			"temp-c": "",
			"current-pending-sector": "",
			"offline-uncorrectable": "",
			"power-on-time": "",
			"health": ""
		}
		bay["dev-by-path"] = regex.group(3) # third capture group
		bay["bay-id"] = str(new_row_index) + "-" + str(new_bay_index)
		# if symlink exists in /dev/disk/by-path/ then bay is occupied
		if os.path.islink(bay["dev-by-path"]):
			bay["occupied"] = True
			bay["dev"] = os.path.realpath(bay["dev-by-path"])
			bay["partitions"] = count_partitions(bay["dev"])
			if call_smartctl:
				smartctl(bay) # get metadata
				if EXIT_CODE == 0:
					bay["capacity"] = format_bytes(bay["capacity"])
			if call_lsblk:
				key = bay["dev"]
				ms = model_serial[key] if key in model_serial.keys() else ("-", "-")
				bay["model-name"] = ms[model_serial_ind.MODEL]
				bay["serial"] = ms[model_serial_ind.SERIAL]
		# insert copy of bay
		server[row_index-1].append(bay.copy());
	vdev_id.close()
	return server

################################################################################
# function name: get_controller
# receives: nothing
# does: executes lspci and searches for HBA conrtoller card name and
#       then calls modinfo on arg dependent on card type to get driver version
# returns: (controller name, driver version)
################################################################################
def get_controller():
	try:
		stream = subprocess.Popen("lspci", stdout=subprocess.PIPE,
				universal_newlines=True).stdout
	except OSError:
		print("Error executing lspci.")
		exit(1)
	string = stream.read()
	controller = "?"
	drv_vers = "?"
	drv_arg = ""
	
	if re.search("2116",string,re.MULTILINE) != None:
		controller = "LSI 9201-16i"
		drv_arg = "mpt2sas"
	elif re.search("3224",string,re.MULTILINE) != None:
		controller = "LSI 9305-16i"
		drv_arg = "mpt3sas"
	elif len(server["rows"]) == 1:
		controller = "AV15 Base"
		drv_arg = "mpt3sas"
	else:
		return "?","?"
	
	#run modinfo command to obtain the drive version
	try:
		drv_stream = subprocess.Popen(["modinfo", drv_arg], stdout=subprocess.PIPE,
				universal_newlines=True).stdout
	except OSError:
		print("Error executing modinfo.")
		exit(1)
	
	for line in drv_stream:
		regex = re.search("^version:\s+(\d.*)$",line)
		if regex != None:
			drv_vers = regex.group(1)
			break
	return controller, drv_vers

################################################################################
# function name: disk_type
# receives: block device path
# does: reads /sys/block/<device>/queue/rotational to determine if the drive is
#       a HDD or SDD
# returns: "HDD" or "SDD" depending on value read, or "-" if error
################################################################################
def disk_type(device_path):
	#get the value of "/sys/block/[device_name]/queue/rotational
	#this check will return 1 if block device is a spinner, 0 if not
	device_name = os.path.basename(device_path)
	rotational_path = "/sys/block/" + device_name + "/queue/rotational"
	if not os.path.isfile(rotational_path):
		return "-"
	rotational = open(rotational_path, mode='r')
	is_rotational = bool(int(rotational.read(1)))
	return ("HDD" if is_rotational else "SSD")

################################################################################
# function name: choose_output
# receives: bay dictionary from build_server() and output_opt
#           enum (class outputType)
# does: "switches" on output_opt
# returns: string corresponding to chosen output type
################################################################################
def choose_output(bay, output_opt):
	# switch on output_opt to determine output string
	if output_opt == outputType.DEFAULT:
		return bay["dev"] if bay["dev"] else "-"
	if output_opt == outputType.HEALTH:
		return bay["health"] if bay["health"] else "-"
	if output_opt == outputType.MODEL:
		return bay["model-name"] if bay["model-name"] else "-"
	if output_opt == outputType.TYPE:
		return disk_type(bay["dev"])
	if output_opt == outputType.SERIAL:
		return bay["serial"] if bay["serial"] else "-"

################################################################################
# function name: print_bays
# receives: server dictionary ({rows: [], meta: {}})
# does: prints table representing server with output based on
#       output_opt and choose_output() call
# returns: nothing
# DEPRECATED: to be replaced with generic table formatting function
################################################################################
def print_bays(server, colour_opt, output_opt):
	print_array = []
	
	for row in reversed(server["rows"]):
		print_array.append([])
		for bay in row:
			cell_string = bay["bay-id"] + " (" + choose_output(bay, output_opt) + ")"
			print_array[-1].append((cell_string, "GREEN"))
	
	# call pretty table printer here
	
	# test
	for i in range(len(print_array[0])):
		for j in range(len(print_array)):
			print(print_array[j][i], end='')
		print()
	# end test
	
	return
	
	# \/ to be removed from function \/
	
	# TODO: fix column width for model name being too long
	cell_width = 21 if colour_opt else 24
	hr_top = "-"*(cell_width*3+1)
	hr_mid = hr_top
	hr_bot = hr_mid
	div = "|"
	if colour_opt:
		hr_top = box.LT + (box.H*cell_width + box.TT)*(len(server["rows"])-1) + box.H*cell_width + box.TR
		hr_mid = box.LT + (box.H*cell_width + box.CT)*(len(server["rows"])-1) + box.H*cell_width + box.RT
		hr_bot = box.BL + (box.H*cell_width + box.BT)*(len(server["rows"])-1) + box.H*cell_width + box.BR
		div = box.V
	title = "Storinator Disk Info"
	controller = "Disk Controller: " + server["meta"]["disk-controller"]
	driver = "Driver version: " + server["meta"]["driver-version"]
	info_len = max(len(title),len(controller),len(driver))
	info_top = "-"*(info_len+4)
	if colour_opt:
		info_top = box.TL + box.H*(info_len+2) + box.TR
		tmplist = list(hr_top)
		index = len(info_top)-1
		if index + 1 == len(tmplist): # edge of lower table
			tmplist[index] = box.RT
		elif index + 1 > len(tmplist):
			tmplist[-1] = box.TT # last current one
			for char in list(box.H*(index - len(tmplist)) + box.BR):
				tmplist.append(char)
		elif (index) % (cell_width + 1) == 0: # if intersects with bay cell
			tmplist[index] = box.CT
		else:
			tmplist[index] = box.BT
		hr_top = "".join(tmplist)
	print(info_top)
	print(div + " {txt:<{width}} ".format(txt=title,width=info_len) + div)
	print(div + " {txt:<{width}} ".format(txt=controller,width=info_len) + div)
	print(div + " {txt:<{width}} ".format(txt=driver,width=info_len) + div)
	print(hr_top)
	for bay in range(15):
		for row in reversed(server["rows"]):
			output = choose_output(row[bay], output_opt)
			string = " {:<6}  {:<11} ".format(row[bay]["bay-id"],output)
			if colour_opt:
				if row[bay]["occupied"] and row[bay]["partitions"] == 0:
					string = ANSI_colours.GREEN + string + ANSI_colours.END
				elif row[bay]["occupied"]: # partitions present
					string = ANSI_colours.LGREEN + string + ANSI_colours.END
				else:
					string = ANSI_colours.GREY + string + ANSI_colours.END
			else: # no colour
				if row[bay]["occupied"] and row[bay]["partitions"] == 0:
					string = " *" + string
				elif row[bay]["occupied"]: # partitions present
					string = "**" + string
				else:
					string = "  " + string
			print(div + string, end='')
		print(div)
	print(hr_mid)
	for i in reversed(range(len(server["rows"]))):
		print(div + ("{:^21}" if colour_opt else "{:^23}").format("Row " + str(i + 1)), end='')
	print(div)
	print(hr_bot)
	# legend
	print(" <-- motherboard | front plate -->")
	print(" Legend:")
	if colour_opt:
		print(ANSI_colours.GREY + " Empty " +
				ANSI_colours.GREEN + " Occupied (no partitions) " +
				ANSI_colours.LGREEN + " Occupied (1 or more partitions)" +
				ANSI_colours.END)
	else:
		print("    Empty " + "  * Occupied (no partitions) " + " ** Occupied (1 or more partitions)")

################################################################################
# function name: format_bytes
# receives: integer value in bytes
# does: formats size_bytes in SI base units
# returns: string containing formatted size_bytes value
################################################################################
def format_bytes(size_bytes):
	if size_bytes == 0:
		return "0B"
	size_name = ("B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB")
	i = int(math.floor(math.log(size_bytes, 1024)))
	p = math.pow(1024, i)
	s = round(size_bytes / p, 2)
	return "%s %s" % (s, size_name[i])

################################################################################
# function name: main
# receives: nothing
# does: parses CLI options, initializes server dictionary
#       ({rows: [[]], meta: {}}), retrieves controller name and driver version
#       from get_controller(), if-else to decide what data to print
# returns: 0 (success)
################################################################################
def main():
	parser = OptionParser() #use optparse to handle command line arguments
	parser.add_option("-j", "--json", action="store_true",
			dest="json", default=False, help="Output in JSON format")
	parser.add_option("-n", "--no-color", "--no-colour", action="store_false",
			dest="colour", default=True, help="Replace colour coding with asterisks")
	parser.add_option("-H", "--health", action="store_true", dest="outputHealth",
			default=False, help="Output SMARTCTL health")
	parser.add_option("-m", "--model", action="store_true", dest="outputModel",
			default=False, help="Output model names")
	parser.add_option("-t", "--type", action="store_true", dest="outputType",
			default=False, help="Output drive types (HDD/SSD)")
	parser.add_option("-s", "--serial", action="store_true", dest="outputSerial",
			default=False, help="Output serial numbers")
	(options, args) = parser.parse_args()
	
	server = {
		"rows": build_server(options),
		"meta": {
			"disk-controller": "",
			"driver-version": ""
		}
	}
	
	#get server information
	server["meta"]["disk-controller"], server["meta"]["driver-version"] = get_controller()
	
	#print relevant information based on command line arguments
	if(options.json):
		print(json.dumps(server, indent = 4))
	elif(options.outputHealth):
		print_bays(server, options.colour, outputType.HEALTH)
	elif(options.outputModel):
		print_bays(server, options.colour, outputType.MODEL)
	elif(options.outputType):
		print_bays(server, options.colour, outputType.TYPE)
	elif(options.outputSerial):
		print_bays(server, options.colour, outputType.SERIAL)
	else:
		print_bays(server, options.colour, outputType.DEFAULT)
	exit(0)

if __name__ == "__main__":
	main()
