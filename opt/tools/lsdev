#!/usr/bin/env python3
################################################################################
# lsdev - List devices in the system by their alias
#
# Copyright (C) 2020, Josh Boudreau <jboudreau@45drives.com>
#                     Mark Hooper   <mhooper@45drives.com>
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# TODO:
# - re-tune lsosd (low priority)
################################################################################

import json
import re
import os
import subprocess
from optparse import OptionParser
import math
from enum import Enum
from table_print import *

EXIT_CODE = 0

# escape sequences for supported color options
class ANSI_colours:
	LGREEN='\033[1;32m'
	GREEN='\033[0;32m'
	RED='\033[0;31m'
	GREY='\033[1;30m'
	END='\033[0m'

class model_serial_ind:
	MODEL = 0
	SERIAL = 1

################################################################################
# function name: count_partitions
# receives: block device path
# does: reads /proc/partitions, counts lines matching device base name followed
#       by an integer
# returns: number of partitions on device referenced by path
################################################################################
def count_partitions(path):
	partitions = open("/proc/partitions", mode='r')
	blk_name = os.path.basename(path)
	return len(re.findall(blk_name + "\d{1,2}",partitions.read(),re.MULTILINE))

################################################################################
# function name: smartctl_needed
# receives: options from CLI flags
# does: check if smartctl() needs to be called
# returns: True if smartctl() needs to be called, else False
################################################################################
def smartctl_needed(options):
	return options.json or options.outputHealth or options.outputTemp

################################################################################
# function name: smartctl
# receives: drive dictionary from build_server()
# does: executes smartctl -a --json <drive path> and saves output values
#       in drive dictionary
# returns: nothing
################################################################################
def smartctl(drive):
	global EXIT_CODE
	try:
		child = subprocess.Popen(["smartctl", "-a", drive["dev"], "--json"],
				stdout=subprocess.PIPE, universal_newlines=True)
	except OSError:
		print("Error executing smartctl. Is it installed?")
		exit(1)
	if child.wait() != 0:
		EXIT_CODE = child.returncode
		return
	output = json.loads(child.stdout.read())
	drive["model-family"] = output["model_family"] if "model_family" in output.keys() else "?"
	drive["model-name"] = output["model_name"] if "model_name" in output.keys() else "?"
	drive["serial"] = output["serial_number"] if "serial_number" in output.keys() else "?"
	drive["capacity"] = output["user_capacity"]["bytes"] if "user_capacity" in output.keys() else "?"
	drive["firm-ver"] = output["firmware_version"] if "firmware_version" in output.keys() else "?"
	drive["rotation-rate"] = output["rotation_rate"] if "rotation_rate" in output.keys() else "?"
	for attr in output["ata_smart_attributes"]["table"]:
		if attr["name"] == "Start_Stop_Count":
			drive["start-stop-count"] = attr["raw"]["string"]
		elif attr["name"] == "Power_Cycle_Count":
			drive["power-cycle-count"] = attr["raw"]["string"]
		elif attr["name"] == "Temperature_Celsius":
			drive["temp-c"] = attr["raw"]["string"].split()[0] + u"\u2103"
		elif attr["name"] == "Current_Pending_Sector":
			drive["current-pending-sector"] = attr["raw"]["string"]
		elif attr["name"] == "Offline_Uncorrectable":
			drive["offline-uncorrectable"] = attr["raw"]["string"]
	drive["power-on-time"] = output["power_on_time"]["hours"] if "power_on_time" in output.keys() else "?"
	drive["health"] = "OK" if output["smart_status"]["passed"] else "POOR"

################################################################################
# function name: hdparm_needed
# receives: options from CLI flags
# does: check if get_model_serial() needs to be called
# returns: True if get_model_serial() needs to be called, else False
################################################################################
def hdparm_needed(options):
	return (not smartctl_needed(options)) and (options.outputModel or options.outputSerial or options.outputFirm)

################################################################################
# function name: get_model_serial_firmware
# receives: device name
# does: executes hdparm and grabs model, serial, and firm vers
# returns: tuple of model, serial, firm vers
################################################################################
def get_model_serial_firmware(device_name):
	model="unknown"
	serial="unknown"
	firmware="unknown"
	try:
		hdparm_result = subprocess.Popen(
			["hdparm","-I", device_name],
			stdout=subprocess.PIPE,universal_newlines=True
		).stdout
	except OSError:
		print("Error executing hdparm. Is it installed?")
		exit(1)
	for line in hdparm_result:
		regex_model = re.search("^\s+Model Number:\s+(.*)$",line)
		regex_serial = re.search("^\s+Serial Number:\s+(.*)$",line)
		regex_firmware = re.search("^\s+Firmware Revision:\s+(.*)$",line)
		if regex_model != None:
			 model=regex_model.group(1).rstrip()
		if regex_serial != None:
			serial=regex_serial.group(1).rstrip()
		if regex_firmware != None:
			firmware=regex_firmware.group(1).rstrip()
			break
	return (model,serial,firmware)

################################################################################
# function name: check_ceph
# receives: nothing
# does: executes ceph --version
# returns: False if ceph not installed or exit code not 0, else True
################################################################################
def check_ceph():
	try:
		child = subprocess.Popen(
			["ceph","--version"],
			stdout=subprocess.PIPE,universal_newlines=True
		)
	except OSError:
		return False
	if child.wait() != 0:
		return False
	return True

################################################################################
# function name: get_osd_dict
# receives: nothing
# does: executes ceph-volume lvm list --format json, parses output into dict
#       relating device path to osd name
# returns: dictionary of dev path : osd name
################################################################################
def get_osd_dict():
	global EXIT_CODE
	osds = {}
	
	try:
		child = subprocess.Popen(
			["ceph-volume","lvm","list","--format","json"],
			stdout=subprocess.PIPE,universal_newlines=True
		)
	except OSError:
		print("Error executing ceph-volume. Is it installed?")
		exit(1)
	if child.wait() != 0:
		EXIT_CODE = child.returncode
		return
	output = json.loads(child.stdout.read())
	
	for osd in output.keys():
		dev_path = output[osd][0]["devices"][0]
		osds[dev_path] = f"osd.{osd}"
	
	return osds

################################################################################
# function name: build_server
# receives: CLI options
# does: checks if smartctl or get_model_serial need to be called,
#       opens vdev_id.conf, iterates through lines and creates 2D array in
#       server["rows"] containing bay dictionaries, sets values in bay
#       dictionary before inserting into array. Uses either smartctl() to fill
#       all fields of dictionary, uses dict returned by get_model_serial() to
#       model and serial fields, or uses neither depending on call_smartctl and
#       call_lsblk values.
# returns: server dictionary ({rows: [[]], meta: {}})
################################################################################
def build_server(options):
	call_smartctl = smartctl_needed(options)
	call_hdparm = hdparm_needed(options) # grab model num and serial from lslk (get_model_serial())
	# model_serial = get_model_serial() if call_lsblk else {}
	server = [[]]; # server[row][bay]
	CONFIG_PATH = "/etc/zfs" if os.path.isfile("/etc/zfs/vdev_id.conf") else "/etc"
	try:
		vdev_id = open(CONFIG_PATH + "/vdev_id.conf", mode='r')
	except IOError:
		print("Error opening " + CONFIG_PATH + "/vdev_id.conf. Run `dmap`.")
		exit(1)
	row_index = 1
	for line in vdev_id:
		# skip blank lines and comments
		if not line or line == "" or line[0] == '#':
			continue
		# extract bay indices and by-path path
		regex = re.search("^alias\s+(\d{1,2})-(\d{1,2})\s+(.*)$",line)
		if regex == None:
			continue
		new_row_index = int(regex.group(1))
		new_bay_index = int(regex.group(2))
		# new row
		if new_row_index > row_index:
			row_index = new_row_index
			server.append([]); # insert new row
		# process bay
		bay = {
			"dev-by-path": "",
			"bay-id": "",
			"occupied": False,
			"dev": "",
			"partitions": "",
			"model-family": "",
			"model-name": "",
			"serial": "",
			"capacity": "",
			"firm-ver": "",
			"rotation-rate": "",
			"start-stop-count": "",
			"power-cycle-count": "",
			"temp-c": "",
			"current-pending-sector": "",
			"offline-uncorrectable": "",
			"power-on-time": "",
			"health": ""
		}
		bay["dev-by-path"] = regex.group(3) # third capture group
		bay["bay-id"] = str(new_row_index) + "-" + str(new_bay_index)
		# if symlink exists in /dev/disk/by-path/ then bay is occupied
		link = os.path.islink(bay["dev-by-path"])
		if os.path.islink(bay["dev-by-path"]):
			bay["occupied"] = True
			bay["dev"] = os.path.realpath(bay["dev-by-path"])
			bay["partitions"] = count_partitions(bay["dev"])
			if call_smartctl:
				smartctl(bay) # get metadata
				if EXIT_CODE == 0:
					bay["capacity"] = format_bytes(bay["capacity"])
			if call_hdparm:
				bay["model-name"], bay["serial"], bay["firm-ver"] = get_model_serial_firmware(bay["dev"])
				#key = bay["dev"]
				#ms = model_serial[key] if key in model_serial.keys() else ("-", "-")
				#bay["model-name"] = ms[model_serial_ind.MODEL]
				#bay["serial"] = ms[model_serial_ind.SERIAL]
		# insert copy of bay
		server[row_index-1].append(bay.copy());
	vdev_id.close()
	return server

################################################################################
# function name: get_controller
# receives: nothing
# does: executes lspci and searches for HBA conrtoller card name and
#       then calls modinfo on arg dependent on card type to get driver version
# returns: (controller name, driver version)
################################################################################
def get_controller():
	try:
		stream = subprocess.Popen("lspci", stdout=subprocess.PIPE,
				universal_newlines=True).stdout
	except OSError:
		print("Error executing lspci.")
		exit(1)
	string = stream.read()
	controller = "?"
	drv_vers = "?"
	drv_arg = ""
	
	if re.search("2116",string,re.MULTILINE) != None:
		controller = "LSI 9201-16i"
		drv_arg = "mpt2sas"
	elif re.search("3224",string,re.MULTILINE) != None:
		controller = "LSI 9305-16i"
		drv_arg = "mpt3sas"
	elif re.search("3616",string,re.MULTILINE) != None:
		controller = "LSI 9405W-16i"
		drv_arg = "mpt3sas"
	elif len(server["rows"]) == 1:
		controller = "AV15 Base"
		drv_arg = "mpt3sas"
	else:
		return "?","?"
	
	#run modinfo command to obtain the drive version
	try:
		drv_stream = subprocess.Popen(["modinfo", drv_arg], stdout=subprocess.PIPE,
				universal_newlines=True).stdout
	except OSError:
		print("Error executing modinfo.")
		exit(1)
	
	for line in drv_stream:
		regex = re.search("^version:\s+(\d.*)$",line)
		if regex != None:
			drv_vers = regex.group(1)
			break
	return controller, drv_vers

################################################################################
# function name: disk_type
# receives: block device path
# does: reads /sys/block/<device>/queue/rotational to determine if the drive is
#       a HDD or SDD
# returns: "HDD" or "SDD" depending on value read, or "-" if error
################################################################################
def disk_type(device_path):
	#get the value of "/sys/block/[device_name]/queue/rotational
	#this check will return 1 if block device is a spinner, 0 if not
	device_name = os.path.basename(device_path)
	rotational_path = "/sys/block/" + device_name + "/queue/rotational"
	if not os.path.isfile(rotational_path):
		return "-"
	rotational = open(rotational_path, mode='r')
	is_rotational = bool(int(rotational.read(1)))
	return ("HDD" if is_rotational else "SSD")

################################################################################
# function name: no_output_flags
# receives: options from parseOptions
# does: determines if no flags are passed for default output
# returns: True if default output, else False
################################################################################
def no_output_flags(options):
	return (not options.outputHealth and not options.outputModel
			and not options.outputType and not options.outputSerial
			and not options.outputTemp and not options.outputFirm
			and not options.outputOSD)

################################################################################
# function name: choose_output
# receives: bay dictionary from build_server(), output_opt, and Ceph OSD LUT
# does: creates string of info based on passed flags
# returns: string corresponding to chosen output type(s)
################################################################################
def choose_output(bay, options, osd):
	if no_output_flags(options):
		return bay["dev"] if bay["dev"] else "-"
	output = []
	if options.outputDev:
		output.append(bay["dev"].rstrip() if bay["dev"] else "-")
	if options.outputModel:
		output.append(bay["model-name"].rstrip() if bay["model-name"] else "-")
	if options.outputSerial:
		output.append(bay["serial"].rstrip() if bay["serial"] else "-")
	if options.outputFirm:
		output.append(bay["firm-ver"].rstrip() if bay["firm-ver"] else "-")
	if options.outputType:
		output.append(disk_type(bay["dev"]))
	if options.outputHealth:
		output.append(bay["health"].rstrip() if bay["health"] else "-")
	if options.outputTemp:
		output.append(bay["temp-c"].rstrip() if bay["temp-c"] else "-")
	if options.outputOSD:
		output.append(osd[bay["dev"]] if bay["dev"] in osd.keys() else "-")
	return ",".join(output)

################################################################################
# function name: choose_output_header
# receives: options from CLI opt parser
# does: creates header for column based on output options passed
# returns: header string corresponding to chosen output type
################################################################################
def choose_output_header(options):
	if no_output_flags(options):
		return "ID Dev"
	output = []
	if options.outputDev:
		output.append("Dev")
	if options.outputModel:
		output.append("Model")
	if options.outputSerial:
		output.append("Serial")
	if options.outputFirm:
		output.append("Firmware")
	if options.outputType:
		output.append("Type")
	if options.outputHealth:
		output.append("Health")
	if options.outputTemp:
		output.append("Temp C")
	if options.outputOSD:
		output.append("OSD")
	return "ID " + ",".join(output)

################################################################################
# function name: print_bays
# receives: server dictionary ({rows: [], meta: {}}), options, Ceph OSD LUT
# does: prints table representing server with output based on
#       options and choose_output() call
# returns: nothing
# DEPRECATED: to be replaced with generic table formatting function
################################################################################
def print_bays(server, options, osd):
	print_array = []
	
	for row in reversed(server["rows"]):
		print_array.append([])
		for bay in row:
			cell_string = "{txt:<4} (".format(txt=bay["bay-id"]) + choose_output(bay, options, osd) + ")"
			colour = ""
			if options.colour:
				if bay["occupied"] == False:
					colour = "GREY"
				elif bay["partitions"] == 0:
					colour = "GREEN"
				elif bay["partitions"] > 0:
					colour = "LGREEN"
			else:
				if bay["occupied"] and bay["partitions"] == 0:
					cell_string = " * " + cell_string
				elif bay["occupied"] and bay["partitions"] > 0:
					cell_string = "** " + cell_string
				else:
					cell_string = "   " + cell_string
			print_array[-1].append((cell_string, colour))
	
	header_text = [
		"Storinator Disk Info",
		"Disk Controller: " + server["meta"]["disk-controller"],
		"Driver version: " + server["meta"]["driver-version"]
	]
	
	col_headers = []
	for row in reversed(range(len(server["rows"]))):
		h_txt = ("Row " + str(row + 1) + " (" + choose_output_header(options)) + ")"
		col_headers.append(h_txt)
	
	table_print(ansi = options.colour, c_count = len(print_array), c_txt = print_array, c_labels = col_headers, h_txt = header_text, padding = 1)
	
	# legend
	print(" <-- motherboard | front plate -->")
	print(" Legend:")
	if options.colour:
		print(ANSI_colours.GREY + " Empty " +
				ANSI_colours.GREEN + " Occupied (no partitions) " +
				ANSI_colours.LGREEN + " Occupied (1 or more partitions)" +
				ANSI_colours.END)
	else:
		print("    Empty " + "  * Occupied (no partitions) " + " ** Occupied (1 or more partitions)")

################################################################################
# function name: format_bytes
# receives: integer value in bytes
# does: formats size_bytes in SI base units
# returns: string containing formatted size_bytes value
################################################################################
def format_bytes(size_bytes):
	if size_bytes == 0:
		return "0B"
	size_name = ("B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB")
	i = int(math.floor(math.log(size_bytes, 1024)))
	p = math.pow(1024, i)
	s = round(size_bytes / p, 2)
	return "%s %s" % (s, size_name[i])

################################################################################
# function name: main
# receives: nothing
# does: parses CLI options, initializes server dictionary
#       ({rows: [[]], meta: {}}), retrieves controller name and driver version
#       from get_controller(), if-else to decide what data to print
# returns: 0 (success)
################################################################################
def main():
	parser = OptionParser() #use optparse to handle command line arguments
	parser.add_option("-j", "--json", action="store_true",
			dest="json", default=False, help="Output in JSON format")
	parser.add_option("-n", "--no-color", "--no-colour", action="store_false",
			dest="colour", default=True, help="Replace colour coding with asterisks")
	parser.add_option("-d", "--device", action="store_true", dest="outputDev",
			default=False, help="Output device name \"/dev/sd<x>/\"")
	parser.add_option("-H", "--health", action="store_true", dest="outputHealth",
			default=False, help="Output SMARTCTL health (slow)")
	parser.add_option("-m", "--model", action="store_true", dest="outputModel",
			default=False, help="Output model names")
	parser.add_option("-t", "--type", action="store_true", dest="outputType",
			default=False, help="Output drive types (HDD/SSD)")
	parser.add_option("-s", "--serial", action="store_true", dest="outputSerial",
			default=False, help="Output serial numbers")
	parser.add_option("-T", "--temp", action="store_true", dest="outputTemp",
			default=False, help="Output temperature (deg-C) (slow)")
	parser.add_option("-f", "--firmware", action="store_true", dest="outputFirm",
			default=False, help="Output firmware version")
	parser.add_option("-o", "--ceph-osd", action="store_true", dest="outputOSD",
			default=False, help="Output OSD name - Ceph only")
	(options, args) = parser.parse_args()
	
	server = {
		"rows": build_server(options),
		"meta": {
			"disk-controller": "",
			"driver-version": ""
		}
	}
	
	#get Ceph OSD LUT
	osd = {}
	if options.outputOSD:
		if check_ceph():
			osd = get_osd_dict()
		else:
			log("-o --ceph-osd can only be used with Ceph.")
	
	#get server information
	server["meta"]["disk-controller"], server["meta"]["driver-version"] = get_controller()
	
	#print relevant information based on command line arguments
	if(options.json):
		print(json.dumps(server, indent = 4))
	else:
		print_bays(server, options, osd)
	exit(0)

if __name__ == "__main__":
	main()