#!/usr/bin/env bash
#
# /opt/45drives/ubm/locate_slot SLOT_NAME ON|OFF
#
# Outputs env variable values for UBM_BP_NUM
#
# Part of 45drives-tools
#
# Authors
# Josh Boudreau <jboudreau@45drives.com>

[ -z "$BASH" ] && echo "Must use bash" >&2 && exit 1

usage() {
  local exit_code=${1:-0}
  printf "Usage: %s: [ -a | [ -s SLOT_NAME | -i SLOT_INDEX ]... ] [-t SECONDS] on|off\n" "$0" >&2
  exit "$exit_code"
}

slot_nums=()
slot_names=()
all_flag=
timeout=

while getopts 's:i:at:h' opt; do
  case $opt in
  s)
    slot_names+=("$OPTARG")
    ;;
  i)
    slot_nums+=("$OPTARG")
    ;;
  a)
    all_flag=1
    ;;
  t)
    timeout="$OPTARG"
    ;;
  h)
    usage 0
    ;;
  *)
    printf "Unknown flag: %s\n" "$opt" >&2
    usage 2
    ;;
  esac
done
shift $((OPTIND - 1))

[[ $# -ne 1 ]] && usage 2

ON_OFF=$1
SG_SES_FLAG=
case "$ON_OFF" in
on | ON)
  SG_SES_FLAG=--set
  ;;
off | OFF)
  SG_SES_FLAG=--clear
  ;;
*)
  echo "Invalid option" >&2
  usage 2
  ;;
esac

readarray -t SG_ENCLOSURES < <(lsscsi -g | awk '$2 == "enclosu" {print $NF}')
[[ ${#SG_ENCLOSURES[@]} -eq 0 ]] && echo "Failed to find enclosure scsi generic devices" >&2 && exit 1

SCRIPT_DIR="$(dirname -- "$(readlink -f -- "${BASH_SOURCE[0]}")")"
# shellcheck source=./ubm_funcs.sh
source "$SCRIPT_DIR/ubm_funcs.sh" || {
  RESULT=$?
  echo Failed to source "$SCRIPT_DIR/ubm_funcs.sh" >&2
  exit $RESULT
}

if [[ -n "$all_flag" ]]; then
  readarray -t slot_nums < <(all_slot_nums)
else
  for slot_name in "${slot_names[@]}"; do
    slot_num=$(slot_name_to_slot_num "$slot_name") || die $? "Failed to convert slot name to slot num: $slot_name"
    slot_nums+=("$slot_num")
  done
fi

[[ ${#slot_nums[@]} -eq 0 ]] && echo "No slots given" >&2 && usage 2

for slot_num in "${slot_nums[@]}"; do
  for encl in "${SG_ENCLOSURES[@]}"; do
    sg_ses --quiet "$SG_SES_FLAG" locate --dev-slot-num="$slot_num" "$encl" >/dev/null 2>&1 &
  done
done
